---
layout: post
title: c/c++中的static
---

#### static的作用主要有两种:

* 第一个作用是限定作用域
* 第二个作用是保持变量内容持久化

---
#### c语言中static的用法：

#####  全局静态变量：

　　 用法：在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。 `static int temp`；

　　 内存中的位置：静态存储区，在整个程序运行期间一直存在。

　　 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

　　 作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

#####  局部静态变量：

　　在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。

　　内存中的位置：静态存储区

　　初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

　　作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

#####  静态函数：

　　在函数返回类型前加关键字static，函数就定义成静态函数。函数的定义和生命在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用；

---
#### c++中static的用法：

##### 类的静态成员：

```
class A
{
private:
  static int val;
};
```

&emsp;&emsp;在cpp中必须对他进行初始化，初始化时使用作用域运算符来标明他所属类，其属于该类的所有成员共有，只有一个拷贝

&emsp;&emsp;`int A::val = 0;`

##### 类的静态成员函数：
```
class A
{
private:
  static int func(int x);
};
```
&emsp;&emsp;实现的时候也不需要static的修饰，因为static是声明性关键字；类的静态函数是该类的范畴内的全局函数，不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用；实际上，他就是增加了类的访问权限的全局函数；

&emsp;&emsp;` void  A::func(int);`

&emsp;&emsp;静态成员函数可以继承和覆盖，但无法是虚函数；

##### 只在cpp内有效的全局变量：

&emsp;&emsp;在cpp文件的全局范围内声明：

&emsp;&emsp;`static int val = 0;`

&emsp;&emsp;这个变量的含义是该cpp内有效，但是其他的cpp文件不能访问这个变量；如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量；

##### 只在cpp内有效的全局函数：

&emsp;&emsp;用函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；

&emsp;&emsp;warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；
