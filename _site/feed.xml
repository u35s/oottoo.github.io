<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.0">Jekyll</generator><link href="http://0.0.0.0:4001/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4001/" rel="alternate" type="text/html" /><updated>2018-01-20T03:13:57+08:00</updated><id>http://0.0.0.0:4001/</id><title type="html">游山玩水</title><author><name>u35s</name></author><entry><title type="html">BoltDB实现机制分析</title><link href="http://0.0.0.0:4001/2018/01/15/bolt-realization.html" rel="alternate" type="text/html" title="BoltDB实现机制分析" /><published>2018-01-15T00:00:00+08:00</published><updated>2018-01-15T00:00:00+08:00</updated><id>http://0.0.0.0:4001/2018/01/15/bolt-realization</id><content type="html" xml:base="http://0.0.0.0:4001/2018/01/15/bolt-realization.html">&lt;p&gt;Bolt是根据Howard Chu的LMDB项目开发的一个存粹的go语言版的key/value存储.
它的目标是为项目提供一个简单、高效、可靠的嵌入式数据库而不是要求一个完成的数据库服务器，例如Postgres和MySQL.
用作者的话说,Bolt只提供简单key/value存储,没有其他的特性,以后也不会有,加上Bolt原本的代码精简,质量高,很适合作为对数据库工作原理的感兴趣的同学的第一选择&lt;/p&gt;

&lt;h3 id=&quot;bolt的实现&quot;&gt;Bolt的实现&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Bolt使用操作体统提供的mmap技术避免I/O操作,使文件读取效率提高。&lt;/li&gt;
  &lt;li&gt;使用单写多读,写时复制实现无锁MVCC&lt;/li&gt;
  &lt;li&gt;内部使用B+树实现高性能随机读&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;主要的数据结构&quot;&gt;主要的数据结构&lt;/h3&gt;
&lt;p&gt;Bolt的主要数据结构有DB,Bucket,Tx,Cursor,node,inode,page&lt;/p&gt;

&lt;p&gt;DB表示数据库中的Bucket集合,Bucket表示数据库中的键值对集合,好比DB是Mysql,Bucket是Mysql中的一张表,键值对对应Mysql表中的一行数据. Cursor表示一个迭代器,该迭代器可以按顺序遍历bucket中的所有键/值对. Tx表示数据库中的一个只读或读写事务,只读事务可以用来创建Cursor,检索数据,读写事务还可以创建,删除Bucket和键. node表示一个在内存中的反序列化的page,inode是一个node中的内部节点,可以用来指向page中的元素或者还未被被添加到page中的元素。通常说的键值对就对应一个inode.&lt;/p&gt;

&lt;h3 id=&quot;存储过程&quot;&gt;存储过程&lt;/h3&gt;
&lt;p&gt;不管是添加,删除还是读取,都需要先打开数据库,并获取一个事务,读事务中不允许进行任更改,只能检索bucket、检索值. 在读写事务结束时如果没有错误则提交事务,对应数据被更改,否则事务期间的所有的更改都被丢弃.不管是读取，删除还是写入,都需要通过Cursor来找到对应键的位置信息.如果是读取,比较对应位置的键和目标键是否相等,相等则找到并且返回,不相等则不存在返回nil.如果是删除,也比较对应位置的键和目标键是否相等,相等则删除对应数据.添加的话则在对应的位置插入对应值.&lt;/p&gt;

&lt;p&gt;其中查找特定键的实现是用B+树。在提交事务时,如果有删除操作则检查是否需要重新平衡,如果有数据更改则写入到Dirty Page,写入时检测是否有node需要拆分.其中着重说明的是有数据更新的话并且数据长度不一致,很可能导致数据所在Page的改变(默认情况下Bolt的Page在使用%50时就会切页,大数据块也可能占据连续的几页达到100%),这一块的代码很值得一读,会使你对B+树的使用,还有数据的实际存储有更深刻的理解,也会对平常说的分表提升性能(减少了更改数据时整个数据的移动)有更进一步的认识。&lt;/p&gt;</content><author><name>u35s</name></author><summary type="html">Bolt是根据Howard Chu的LMDB项目开发的一个存粹的go语言版的key/value存储. 它的目标是为项目提供一个简单、高效、可靠的嵌入式数据库而不是要求一个完成的数据库服务器，例如Postgres和MySQL. 用作者的话说,Bolt只提供简单key/value存储,没有其他的特性,以后也不会有,加上Bolt原本的代码精简,质量高,很适合作为对数据库工作原理的感兴趣的同学的第一选择</summary></entry><entry><title type="html">加密笔记</title><link href="http://0.0.0.0:4001/2017/10/11/encrytion.html" rel="alternate" type="text/html" title="加密笔记" /><published>2017-10-11T00:00:00+08:00</published><updated>2017-10-11T00:00:00+08:00</updated><id>http://0.0.0.0:4001/2017/10/11/encrytion</id><content type="html" xml:base="http://0.0.0.0:4001/2017/10/11/encrytion.html">&lt;p&gt;AES 高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。&lt;/p&gt;

&lt;p&gt;DES 数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密块密码算法，1976年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。它基于使用56位密钥的对称算法。这个算法因为包含一些机密设计元素，相对短的密钥长度以及怀疑内含美国国家安全局（NSA）的后门而在开始时有争议，DES因此受到了强烈的学院派式的审查，并以此推动了现代的块密码及其密码分析的发展。&lt;/p&gt;

&lt;p&gt;Salsa20是一种流加密算法，由Daniel J. Bernstein提交到eSTREAM。它创建在基于add-rotate-xor（ARX）操作的伪随机函数之上——32位模加、异或（XOR）和循环移位操作。Salsa20映射一个256位密钥、一个64位nonce以及一个64位流位置到一个512位的输出（也存在一个128位密钥的版本）。这使Salsa20具有了不同寻常的优势，用户可以在恒定时间内寻求输出流中的任何位置。它可以在现代x86处理器中提供约每4–14次循环周期一字节的速度[1]，并具有合理的硬件性能。它没有注册专利，并且Bernstein还撰写了几篇对常见架构优化的公有领域实现。[2]Salsa20已被提交到eSTREAM。&lt;/p&gt;

&lt;p&gt;CTR将一个分组密码转换成一个流密码，通过重复加密一个递增计数器，并将产生的数据流与输入连接起来。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CFB使用给定的块返回使用密码反馈模式解密的流。iv必须与块的块大小相同。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>u35s</name></author><summary type="html">AES 高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</summary></entry><entry><title type="html">k8s笔记</title><link href="http://0.0.0.0:4001/2017/10/10/k8s.html" rel="alternate" type="text/html" title="k8s笔记" /><published>2017-10-10T00:00:00+08:00</published><updated>2017-10-10T00:00:00+08:00</updated><id>http://0.0.0.0:4001/2017/10/10/k8s</id><content type="html" xml:base="http://0.0.0.0:4001/2017/10/10/k8s.html">&lt;p&gt;hahahah&lt;/p&gt;

&lt;h3 id=&quot;cidr&quot;&gt;cidr&lt;/h3&gt;
&lt;p&gt;无类别域间路由（Classless Inter-Domain Routing、CIDR）是一个用于给用户分配IP地址以及在互联网上有效地路由IP数据包的对IP地址进行归类的方法。&lt;/p&gt;

&lt;p&gt;CIDR的最大的好处就是可以进行前缀路由聚合。例如， 16个原来的C类（/24）网络现在可以聚合在一起，对外显示了一个/20的网络了（如果这些网络的的地址前20位都相同）。两个对齐的/20网络又可进一步聚合为/19，依此类推。这有效地减少了要对外显示的网络数，防止了路由表爆炸，也遏制了互联网进一步扩大。&lt;/p&gt;

&lt;h3 id=&quot;weave-ip-allocation-design&quot;&gt;weave ip allocation design&lt;/h3&gt;

&lt;p&gt;当启动时，节点被告知子网所有分配的IP范围。每个节点必须具有相同的范围。&lt;/p&gt;

&lt;p&gt;我们通过领导选举的过程来处理并行启动。从本质上说，具有最高id的节点为自己声明了整个范围，然后其他节点可以开始请求它的子空间。&lt;/p&gt;

&lt;p&gt;当一个节点启动时，它会将CRDT初始化为一个空的环。然后等待更新或命令。在节点接收到分配或声明IP地址的命令之前，它并不关心发生了什么，但它需要跟踪它。&lt;/p&gt;

&lt;p&gt;当一个节点第一次接收到这样的命令时，它会参考它的map。如果它看到任何其他节点声称有一些保留，那么它将继续正常分配。否则，如果没有收到这样的更新(例如，我们要么没有收到更新，要么只更新了所有节点条目为空)，那么该节点将启动一个领导人选举。如果该节点具有最高的id，那么该节点就声明整个IP范围本身，在环的开头插入一个标记。&lt;/p&gt;

&lt;p&gt;如果它看到另一个节点具有最高的ID，它会向该节点发送一条消息，建议它是leader。接收这样一条消息的节点将按照上面的方式进行:只有当它看到没有其他节点时，它才会将自己视为具有最高ID的节点。&lt;/p&gt;

&lt;p&gt;请注意，所选的leader可以是一个具有全局最高id的节点，在事件中，如果一个节点具有更高的id，那么它将作为另一个节点做出成为leader的决定。这是好的;新节点本身不会声称自己是leader，直到某个时间过去了，有足够的时间从领导者那里获得更新，从而抢占先机。&lt;/p&gt;

&lt;p&gt;Failures::&lt;/p&gt;

&lt;p&gt;两个没有互相沟通的节点，每个人都可以决定成为领导者-&amp;gt;这是一个根本的问题:如果你不了解别人，你就不能为他们提供补贴。产生的情况实际上是一个网络分区，当节点进行接触时，可以以同样的方式解决。为了缓解这个问题，节点可以开始在一个随机的点上分配IP，以最小化在合并它们的映射之前分配相同IP的机会。&lt;/p&gt;

&lt;p&gt;在发送map-&amp;gt;之前，潜在的领导者就会死亡，这种失败将被底层的Weave对等拓扑发现。需要空间的节点将重新尝试，在所有连接的节点上重新运行领导选举。&lt;/p&gt;

&lt;h3 id=&quot;weave-npc&quot;&gt;weave-npc&lt;/h3&gt;
&lt;p&gt;Weaveworks Kubernetes Network Policy Controller(weave k8s 网络策略控制器)&lt;/p&gt;
&lt;h3 id=&quot;kube-peers&quot;&gt;kube-peers&lt;/h3&gt;
&lt;p&gt;在weaver启动之前，kube-peers会向k8s获取所有已经启动的weave node列表,并以参数方式传递给weaver&lt;/p&gt;
&lt;h3 id=&quot;weave与k8s&quot;&gt;weave与k8s&lt;/h3&gt;
&lt;h3 id=&quot;weave&quot;&gt;weave&lt;/h3&gt;
&lt;p&gt;weave网络共有3中工作模式&lt;/p&gt;

&lt;p&gt;Bridge,此模式下pcap捕获发送给weave的网络包，然后交给weave,weave判断是本节点的就直接发送，否则根据peers找到对应weave所在的node发送出去，对方node利用pcap做类似操作完成网络包投送&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                 +-------+
(container-veth)-+ weave +-(vethwe-bridge)--(vethwe-pcap)
                 +-------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;BridgedFastdp是在Bridge上的改进,利用操作系统提供的Open vSwitch技术取代了weave node间的连接，更加高效&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                 +-------+                                    /----------\
(container-veth)-+ weave +-(vethwe-bridge)--(vethwe-datapath)-+ datapath +
                 +-------+                                    \----------/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Fastdp,”weave” is an Open vSwitch datapath, and capture/injection are as in
BridgedFastdp. Not used by default due to missing conntrack support in
datapath of old kernel versions (https://github.com/weaveworks/weave/issues/1577).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                 /-------\
(container-veth)-+ weave +
                 \-------/

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;weave与calico&quot;&gt;weave与calico&lt;/h3&gt;
&lt;p&gt;BGP(Border Gateway Protocol,边界网关协议)是互联网上一个核心的去中心化自治路由协议,大多数互联网服务提供商（ISP）必须使用BGP来与其他ISP创建路由连接（尤其是当它们采取多宿主连接时）。calico使用BGP协议在每个容器所在的节点创建一个虚拟路由器，来完成跨主机容器间的网络通信&lt;/p&gt;
&lt;h3 id=&quot;weave与flannel&quot;&gt;weave与flannel&lt;/h3&gt;

&lt;h3 id=&quot;cni&quot;&gt;cni&lt;/h3&gt;
&lt;p&gt;CNI(Container Network Interface,容器网络接口)是一个云计算基础项目，它由一个规范和库组成，用于编写插件来在Linux容器中配置网络接口，以及一些支持的插件。CNI只关注容器的网络连接，并在删除容器时删除已分配的资源。因此，CNI有广泛的支持，并且规范很容易实现。&lt;/p&gt;
&lt;h3 id=&quot;cni与k8s&quot;&gt;cni与k8s&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;kubernetes 先创建 pause 容器生成对应的 network namespace&lt;/li&gt;
  &lt;li&gt;调用网络 driver（因为配置的是 CNI，所以会调用 CNI 相关代码）&lt;/li&gt;
  &lt;li&gt;CNI driver 根据配置调用具体的 cni 插件&lt;/li&gt;
  &lt;li&gt;cni 插件给 pause 容器配置正确的网络&lt;/li&gt;
  &lt;li&gt;pod 中其他的容器都是用 pause 的网络&lt;/li&gt;
&lt;/ul&gt;</content><author><name>u35s</name></author><summary type="html">hahahah</summary></entry><entry><title type="html">制作自己的linux</title><link href="http://0.0.0.0:4001/2017/01/02/make-liux-img.html" rel="alternate" type="text/html" title="制作自己的linux" /><published>2017-01-02T00:00:00+08:00</published><updated>2017-01-02T00:00:00+08:00</updated><id>http://0.0.0.0:4001/2017/01/02/make-liux-img</id><content type="html" xml:base="http://0.0.0.0:4001/2017/01/02/make-liux-img.html">&lt;p&gt;编译linux内核 
 制作基于busybox init的init ramfs&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir -p $1/{bin,dev,proc,sys,etc,etc/init.d} 
mknod -m 600 $1/dev/console c 5 1
mknod -m 600 $1/dev/null c 1 2
mknod -m 600 $1/dev/tty c 4 1
mknod -m 600 $1/dev/tty1 c 4 1
cp /bin/busybox $1/bin/
$1/bin/busybox --install $1/bin
cp $1/bin/linuxrc $1//init
printf '%s\n' &quot;::sysinit:/etc/init.d/rcS&quot; &quot;::askfirst:/bin/sh&quot; &amp;gt; $1/etc/inittab
printf '%s\n' &quot;#!/bin/sh&quot; &quot;mount -t proc proc /proc&quot; &quot;mount -t sysfs sysfs /sys&quot; &quot;mdev -s&quot; &amp;gt; $1/etc/init.d/rcS
chmod +x $1/etc/init.d/rcS
touch $1/etc/mdev.conf
cd $1
find . | cpio -oHnewc | gzip &amp;gt; ../initramfs.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;qemu 启动自己的系统&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;qemu-system-x86_64 -kernel bzImage -initrd initramfs.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>u35s</name></author><summary type="html">编译linux内核 制作基于busybox init的init ramfs</summary></entry><entry><title type="html">docker centos 中文乱码</title><link href="http://0.0.0.0:4001/2017/01/01/centos-docker-lm.html" rel="alternate" type="text/html" title="docker centos 中文乱码" /><published>2017-01-01T00:00:00+08:00</published><updated>2017-01-01T00:00:00+08:00</updated><id>http://0.0.0.0:4001/2017/01/01/centos-docker-lm</id><content type="html" xml:base="http://0.0.0.0:4001/2017/01/01/centos-docker-lm.html">&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum -y install kde-l10n-Chinese &amp;amp;&amp;amp; yum -y reinstall glibc-common
localedef -c -f UTF-8 -i zh_CN zh_CN.utf8
export LC_ALL=zh_CN.utf8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>u35s</name></author><summary type="html">yum -y install kde-l10n-Chinese &amp;amp;&amp;amp; yum -y reinstall glibc-common localedef -c -f UTF-8 -i zh_CN zh_CN.utf8 export LC_ALL=zh_CN.utf8</summary></entry><entry><title type="html">golang标准库</title><link href="http://0.0.0.0:4001/2016/08/09/go-pkg.html" rel="alternate" type="text/html" title="golang标准库" /><published>2016-08-09T00:00:00+08:00</published><updated>2016-08-09T00:00:00+08:00</updated><id>http://0.0.0.0:4001/2016/08/09/go-pkg</id><content type="html" xml:base="http://0.0.0.0:4001/2016/08/09/go-pkg.html">&lt;p&gt;hahahaha&lt;/p&gt;

&lt;h4 id=&quot;并发同步&quot;&gt;并发同步&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;sync.Mutex 互斥锁,阻塞其他routine&lt;/li&gt;
  &lt;li&gt;sync.RWMutex 读写锁,多个读锁不会阻塞,写锁阻塞routine&lt;/li&gt;
  &lt;li&gt;sync.Once 保证只执行一次&lt;/li&gt;
  &lt;li&gt;sync.Pool 回收利用，减少GC&lt;/li&gt;
  &lt;li&gt;sync.Cond 唤醒睡眠的routine可用&lt;/li&gt;
  &lt;li&gt;sync.Map  线程安全的map,原子和互斥锁实现&lt;/li&gt;
  &lt;li&gt;sync.WaitGroup 等待一组routine运行完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;排序&quot;&gt;排序&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;sort.Sort 对实现接口的数据排序&lt;/li&gt;
  &lt;li&gt;sort.Slice 切片闭包排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;可能造成危险的东东&quot;&gt;可能造成危险的东东&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;unsafe.Offsetof  可以获得结构体成员相对于首地址的偏移量&lt;/li&gt;
  &lt;li&gt;unsage.Sizeof   可以获得结构体的大小&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;系统相关&quot;&gt;系统相关&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;runtime.NumCPU 系统cpu数量&lt;/li&gt;
  &lt;li&gt;runtime.GOMAXPROCS 设置工作线程数量&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;系统调用&quot;&gt;系统调用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;syscall.SIGHUP 信号&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;系统&quot;&gt;系统&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;os.Exit(1) 退出程序&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;容器链表&quot;&gt;容器(链表)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;container&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;上下文&quot;&gt;上下文&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;context 多个routine之间通信,处理超时等情况&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;io相关&quot;&gt;io相关&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;方便Write,Read操作封装&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;编译&quot;&gt;编译&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;builtin&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;反射&quot;&gt;反射&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;reflect&lt;/li&gt;
&lt;/ul&gt;</content><author><name>u35s</name></author><summary type="html">hahahaha</summary></entry><entry><title type="html">修改goimports导包优先级</title><link href="http://0.0.0.0:4001/2016/08/08/go-imports.html" rel="alternate" type="text/html" title="修改goimports导包优先级" /><published>2016-08-08T00:00:00+08:00</published><updated>2016-08-08T00:00:00+08:00</updated><id>http://0.0.0.0:4001/2016/08/08/go-imports</id><content type="html" xml:base="http://0.0.0.0:4001/2016/08/08/go-imports.html">&lt;p&gt;goimports导包按照包的名字长短来排列包的优先级,实际开发中有个多个项目下都有某个库的代码,在自动导入包的时候可能导的是另一个项目的,可实际却要导入本项目中库,经过查看源代码,发现按照下面的步骤即可实现:&lt;/p&gt;

&lt;p&gt;在golang.org/x/tools/imports/fix.go中找到sort.Sort(byImportPathShortLength(candidates))这一行注释掉,添加一下代码,然后重新编译goimports&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var _firstDir string
_paths := strings.Split(filename, &quot;/&quot;)
for i := range _paths {
	if _paths[i] == &quot;src&quot; {
		if len(_paths) &amp;gt; i+1 {
			_firstDir = _paths[i+1]
		}
		break
	}
}
//sort.Slice 在go1.8以下不可用,请参照byImportPathShortLength
sort.Slice(candidates, func(i, j int) bool {
	_paths = strings.Split(candidates[i].importPathShort, &quot;/&quot;)
	fmt.Println(_paths, _firstDir)
	return _paths[0] == _firstDir
})

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;由于上面的代码根据传入的文件名找到第一个目录,所以在goimports需要传入文件全名,我们用vim开发,VBudle管理插件,go插件是vim-go,相应的vim脚本在~/.vim/bundle/vim-go/autoload/go/fmt.vim,修改其中expand(“%”)为expand(“%:p”)即可。&lt;/p&gt;</content><author><name>u35s</name></author><summary type="html">goimports导包按照包的名字长短来排列包的优先级,实际开发中有个多个项目下都有某个库的代码,在自动导入包的时候可能导的是另一个项目的,可实际却要导入本项目中库,经过查看源代码,发现按照下面的步骤即可实现:</summary></entry></feed>